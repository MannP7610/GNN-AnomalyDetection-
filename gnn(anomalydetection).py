# -*- coding: utf-8 -*-
"""GNN(AnomalyDetection).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1h_2l9tZAMweqq3_jdnfiiCj1edJNircv
"""

!pip install torch torchvision torchaudio torch-geometric networkx numpy pandas

import pandas as pd
import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim
import networkx as nx
from torch_geometric.data import Data
from torch_geometric.nn import GCNConv

df = pd.read_csv("/content/drive/MyDrive/manufacturing_test_data.csv")

status_mapping = {"Stopped": 0, "Running": 1}
df["M1_Status"] = df["M1_Status"].map(status_mapping)
df["M2_Status"] = df["M2_Status"].map(status_mapping)
df["M3_Status"] = df["M3_Status"].map(status_mapping)

# Create graph structure
G = nx.Graph()
machines = ["M1", "M2", "M3"]

for machine in machines:
    G.add_node(machine)

G.add_edge("M1", "M2")
G.add_edge("M2", "M3")
G.add_edge("M3", "M1")

node_map = {machine: i for i, machine in enumerate(machines)}
edge_index = torch.tensor([[node_map[u], node_map[v]] for u, v in G.edges()], dtype=torch.long).t().contiguous()

num_samples = len(df)
features = np.zeros((num_samples, len(machines) * 2))

for i, row in df.iterrows():
    features[i] = [
        row["M1_Status"], row["M1_Worker_Count"],
        row["M2_Status"], row["M2_Worker_Count"],
        row["M3_Status"], row["M3_Worker_Count"]
    ]

x = torch.tensor(features, dtype=torch.float)

class GCNAnomalyDetector(nn.Module):
    def __init__(self, input_dim, hidden_dim, output_dim):
        super(GCNAnomalyDetector, self).__init__()
        self.conv1 = GCNConv(input_dim, hidden_dim)
        self.conv2 = GCNConv(hidden_dim, output_dim)

    def forward(self, x, edge_index):
        x = torch.relu(self.conv1(x, edge_index))
        x = self.conv2(x, edge_index)
        return x

input_dim = x.shape[1]
hidden_dim = 16
output_dim = input_dim
model = GCNAnomalyDetector(input_dim, hidden_dim, output_dim)

optimizer = optim.Adam(model.parameters(), lr=0.01)
criterion = nn.MSELoss()

import matplotlib.pyplot as plt
import seaborn as sns

def plot_feature_correlation(df):
    """Heatmap to visualize correlation between numerical variables only"""

    # Select only numeric columns
    numeric_df = df.select_dtypes(include=["number"])

    plt.figure(figsize=(10, 6))
    sns.heatmap(numeric_df.corr(), annot=True, cmap="coolwarm", fmt=".2f", linewidths=0.5)
    plt.title("Feature Correlation Heatmap")
    plt.show()

# Call function again
plot_feature_correlation(df)

num_epochs = 100
for epoch in range(num_epochs):
    model.train()
    optimizer.zero_grad()
    output = model(x, edge_index)
    loss = criterion(output, x)
    loss.backward()
    optimizer.step()

print("Training Completed!")

model.eval()
with torch.no_grad():
    reconstructed = model(x, edge_index)
    anomaly_scores = torch.mean((reconstructed - x) ** 2, dim=1).numpy()

threshold = np.percentile(anomaly_scores, 95)
all_anomalies = anomaly_scores > threshold

m3_to_m1_cases = ((df["M1_Status"] == 1) & (df["M3_Status"] == 1)).to_numpy()
true_anomalies = np.logical_and(all_anomalies, ~m3_to_m1_cases)

print(f"Total anomalies detected: {np.sum(all_anomalies)}")
print(f"Final anomalies (excluding M3â†’M1 cases): {np.sum(true_anomalies)}")

